{"dependencies":[{"name":"babel-runtime/helpers/extends","loc":{"line":1,"column":21}},{"name":"babel-runtime/helpers/classCallCheck","loc":{"line":2,"column":28}},{"name":"babel-runtime/helpers/possibleConstructorReturn","loc":{"line":3,"column":39}},{"name":"babel-runtime/helpers/inherits","loc":{"line":4,"column":22}},{"name":"react","loc":{"line":5,"column":18}},{"name":"prop-types","loc":{"line":6,"column":22}},{"name":"classnames","loc":{"line":7,"column":23}},{"name":"warning","loc":{"line":8,"column":20}},{"name":"./util","loc":{"line":9,"column":109}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.contextTypes = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require(\"classnames\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _warning = require(\"warning\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction noop() {}\n\nvar contextTypes = exports.contextTypes = {\n  rcTree: _propTypes2.default.shape({\n    selectable: _propTypes2.default.bool\n  })\n};\n\nvar Tree = function (_React$Component) {\n  (0, _inherits3.default)(Tree, _React$Component);\n\n  function Tree(props) {\n    (0, _classCallCheck3.default)(this, Tree);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var checkedKeys = _this.calcCheckedKeys(props);\n    _this.state = {\n      expandedKeys: _this.calcExpandedKeys(props),\n      checkedKeys: checkedKeys.checkedKeys,\n      halfCheckedKeys: checkedKeys.halfCheckedKeys,\n      selectedKeys: _this.calcSelectedKeys(props),\n      dragNodesKeys: '',\n      dragOverNodeKey: '',\n      dropNodeKey: ''\n    };\n    return _this;\n  }\n\n  Tree.prototype.getChildContext = function getChildContext() {\n    var selectable = this.props.selectable;\n\n    return {\n      rcTree: {\n        selectable: selectable\n      }\n    };\n  };\n\n  Tree.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var props = this.props;\n\n    var newState = {};\n    var expandedKeys = nextProps.expandedKeys !== props.expandedKeys ? this.calcExpandedKeys(nextProps, true) : undefined;\n    if (expandedKeys) {\n      newState.expandedKeys = expandedKeys;\n    }\n\n    var checkedKeys = nextProps.checkedKeys !== props.checkedKeys || props.loadData ? this.calcCheckedKeys(nextProps, true) : undefined;\n    if (checkedKeys) {\n      newState.checkedKeys = checkedKeys.checkedKeys;\n      newState.halfCheckedKeys = checkedKeys.halfCheckedKeys;\n    }\n\n    var selectedKeys = nextProps.selectedKeys !== props.selectedKeys ? this.calcSelectedKeys(nextProps, true) : undefined;\n    if (selectedKeys) {\n      newState.selectedKeys = selectedKeys;\n    }\n    this.setState(newState);\n  };\n\n  Tree.prototype.onDragStart = function onDragStart(e, treeNode) {\n    this.dragNode = treeNode;\n    var newState = {\n      dragNodesKeys: this.getDragNodesKeys(treeNode)\n    };\n    var expandedKeys = this.getExpandedKeys(treeNode, false);\n    if (expandedKeys) {\n      newState.expandedKeys = expandedKeys;\n    }\n    this.setState(newState);\n    this.props.onDragStart({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onDragEnter = function onDragEnter(e, treeNode) {\n    var _this2 = this;\n\n    var dropPosition = this.calcDropPosition(e, treeNode);\n    if (this.dragNode.props.eventKey === treeNode.props.eventKey && dropPosition === 0) {\n      this.setState({\n        dragOverNodeKey: '',\n        dropPosition: null\n      });\n      return;\n    }\n    this.setState({\n      dragOverNodeKey: treeNode.props.eventKey,\n      dropPosition: dropPosition\n    });\n\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(function (key) {\n      clearTimeout(_this2.delayedDragEnterLogic[key]);\n    });\n    this.delayedDragEnterLogic[treeNode.props.pos] = setTimeout(function () {\n      var expandedKeys = _this2.getExpandedKeys(treeNode, true);\n      if (expandedKeys) {\n        _this2.setState({ expandedKeys: expandedKeys });\n      }\n      _this2.props.onDragEnter({\n        event: e,\n        node: treeNode,\n        expandedKeys: expandedKeys && [].concat(expandedKeys) || [].concat(_this2.state.expandedKeys)\n      });\n    }, 400);\n  };\n\n  Tree.prototype.onDragOver = function onDragOver(e, treeNode) {\n    this.props.onDragOver({ event: e, node: treeNode });\n  };\n\n  Tree.prototype.onDragLeave = function onDragLeave(e, treeNode) {\n    this.props.onDragLeave({ event: e, node: treeNode });\n  };\n\n  Tree.prototype.onDrop = function onDrop(e, treeNode) {\n    var state = this.state;\n\n    var eventKey = treeNode.props.eventKey;\n    this.setState({\n      dragOverNodeKey: '',\n      dropNodeKey: eventKey\n    });\n    if (state.dragNodesKeys.indexOf(eventKey) > -1) {\n      (0, _warning2.default)(false, 'Can not drop to dragNode(include it\\'s children node)');\n      return;\n    }\n\n    var posArr = treeNode.props.pos.split('-');\n    var res = {\n      event: e,\n      node: treeNode,\n      dragNode: this.dragNode,\n      dragNodesKeys: [].concat(state.dragNodesKeys),\n      dropPosition: state.dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (state.dropPosition !== 0) {\n      res.dropToGap = true;\n    }\n    this.props.onDrop(res);\n  };\n\n  Tree.prototype.onDragEnd = function onDragEnd(e, treeNode) {\n    this.setState({\n      dragOverNodeKey: ''\n    });\n    this.props.onDragEnd({ event: e, node: treeNode });\n  };\n\n  Tree.prototype.onExpand = function onExpand(treeNode) {\n    var _this3 = this;\n\n    var props = this.props,\n        state = this.state;\n\n    var expanded = !treeNode.props.expanded;\n    var expandedKeys = [].concat(state.expandedKeys);\n    var eventKey = treeNode.props.eventKey;\n\n    var index = expandedKeys.indexOf(eventKey);\n    if (expanded && index === -1) {\n      expandedKeys.push(eventKey);\n    } else if (!expanded && index > -1) {\n      expandedKeys.splice(index, 1);\n    }\n\n    var controlled = 'expandedKeys' in props;\n    if (!controlled) {\n      this.setState({ expandedKeys: expandedKeys });\n    }\n    props.onExpand(expandedKeys, { node: treeNode, expanded: expanded });\n\n    // After data loaded, need set new expandedKeys\n    if (expanded && props.loadData) {\n      return props.loadData(treeNode).then(function () {\n        if (!controlled) {\n          _this3.setState({ expandedKeys: expandedKeys });\n        }\n      });\n    }\n  };\n\n  Tree.prototype.onSelect = function onSelect(treeNode) {\n    var props = this.props,\n        state = this.state;\n\n    var eventKey = treeNode.props.eventKey;\n    var selected = !treeNode.props.selected;\n\n    var selectedKeys = [].concat(state.selectedKeys);\n    if (!selected) {\n      var index = selectedKeys.indexOf(eventKey);\n      selectedKeys.splice(index, 1);\n    } else if (!props.multiple) {\n      selectedKeys = [eventKey];\n    } else {\n      selectedKeys.push(eventKey);\n    }\n\n    // TODO: can be optimized if we remove selectedNodes in API\n    var selectedNodes = [];\n    if (selectedKeys.length) {\n      (0, _util.traverseTreeNodes)(props.children, function (item) {\n        if (selectedKeys.indexOf(item.key) !== -1) {\n          selectedNodes.push(item);\n        }\n      });\n    }\n\n    if (!('selectedKeys' in props)) {\n      this.setState({\n        selectedKeys: selectedKeys\n      });\n    }\n\n    var eventObj = {\n      event: 'select',\n      selected: selected,\n      node: treeNode,\n      selectedNodes: selectedNodes\n    };\n    props.onSelect(selectedKeys, eventObj);\n  };\n\n  Tree.prototype.onMouseEnter = function onMouseEnter(e, treeNode) {\n    this.props.onMouseEnter({ event: e, node: treeNode });\n  };\n\n  Tree.prototype.onMouseLeave = function onMouseLeave(e, treeNode) {\n    this.props.onMouseLeave({ event: e, node: treeNode });\n  };\n\n  Tree.prototype.onContextMenu = function onContextMenu(e, treeNode) {\n    if (this.props.onRightClick) {\n      e.preventDefault();\n      this.props.onRightClick({ event: e, node: treeNode });\n    }\n  };\n\n  // all keyboard events callbacks run from here at first\n\n\n  Tree.prototype.getOpenTransitionName = function getOpenTransitionName() {\n    var props = this.props;\n    var transitionName = props.openTransitionName;\n    var animationName = props.openAnimation;\n    if (!transitionName && typeof animationName === 'string') {\n      return props.prefixCls + '-open-' + animationName;\n    }\n    return transitionName;\n  };\n\n  Tree.prototype.getDragNodesKeys = function getDragNodesKeys(treeNode) {\n    var dragNodesKeys = [];\n    (0, _util.traverseTreeNodes)(treeNode.props.children, function (item, index, pos, key) {\n      if ((0, _util.isPositionPrefix)(treeNode.props.pos, pos)) {\n        dragNodesKeys.push(key);\n      }\n    });\n    dragNodesKeys.push(treeNode.props.eventKey || treeNode.props.pos);\n    return dragNodesKeys;\n  };\n\n  Tree.prototype.getExpandedKeys = function getExpandedKeys(treeNode, expand) {\n    var eventKey = treeNode.props.eventKey;\n    var expandedKeys = this.state.expandedKeys;\n    var expandedIndex = expandedKeys.indexOf(eventKey);\n    if (!expand && expandedIndex > -1) {\n      var exKeys = [].concat(expandedKeys);\n      exKeys.splice(expandedIndex, 1);\n      return exKeys;\n    }\n    if (expand && expandedKeys.indexOf(eventKey) === -1) {\n      return expandedKeys.concat([eventKey]);\n    }\n  };\n\n  Tree.prototype.generateTreeNodesStates = function generateTreeNodesStates(children, checkedKeys) {\n    var checkedPositions = [];\n    var treeNodesStates = {};\n    (0, _util.traverseTreeNodes)(children, function (item, _, pos, key, childrenPos, parentPos) {\n      treeNodesStates[pos] = {\n        node: item,\n        key: key,\n        checked: false,\n        halfChecked: false,\n        disabled: item.props.disabled,\n        disableCheckbox: item.props.disableCheckbox,\n        childrenPos: childrenPos,\n        parentPos: parentPos\n      };\n      if (checkedKeys.indexOf(key) !== -1) {\n        treeNodesStates[pos].checked = true;\n        checkedPositions.push(pos);\n      }\n    });\n    checkedPositions.forEach(function (checkedPosition) {\n      (0, _util.updateCheckState)(treeNodesStates, checkedPosition, true);\n    });\n    return treeNodesStates;\n  };\n\n  Tree.prototype.calcExpandedKeys = function calcExpandedKeys(props, isNotInit) {\n    var expandedKeys = props.expandedKeys || (isNotInit ? undefined : props.defaultExpandedKeys);\n    if (!expandedKeys) {\n      return undefined;\n    }\n    var expandAll = isNotInit ? false : props.defaultExpandAll;\n    if (!expandAll && !props.autoExpandParent) {\n      return expandedKeys;\n    }\n\n    var expandedPositionArr = [];\n    if (props.autoExpandParent) {\n      (0, _util.traverseTreeNodes)(props.children, function (item, index, pos, key) {\n        if (expandedKeys.indexOf(key) > -1) {\n          expandedPositionArr.push(pos);\n        }\n      });\n    }\n    var filterExpandedKeysSet = {};\n    (0, _util.traverseTreeNodes)(props.children, function (item, index, pos, key) {\n      if (expandAll) {\n        filterExpandedKeysSet[key] = true;\n      } else if (props.autoExpandParent) {\n        var isCurrentParentOfExpanded = expandedPositionArr.some(function (p) {\n          return (0, _util.isPositionPrefix)(pos, p);\n        });\n        if (isCurrentParentOfExpanded) {\n          filterExpandedKeysSet[key] = true;\n        }\n      }\n    });\n    var filterExpandedKeys = Object.keys(filterExpandedKeysSet);\n    return filterExpandedKeys.length ? filterExpandedKeys : expandedKeys;\n  };\n\n  Tree.prototype.calcCheckedKeys = function calcCheckedKeys(props, isNotInit) {\n    if (!props.checkable) {\n      return { checkedKeys: [], halfCheckedKeys: [] };\n    }\n\n    var checkedKeys = props.checkedKeys || (isNotInit && !props.loadData ? undefined : props.defaultCheckedKeys);\n    if (!checkedKeys) {\n      return undefined;\n    }\n    if (Array.isArray(checkedKeys)) {\n      checkedKeys = { checkedKeys: checkedKeys, halfCheckedKeys: [] };\n    } else if ((typeof checkedKeys === \"undefined\" ? \"undefined\" : _typeof(checkedKeys)) === 'object') {\n      checkedKeys = { checkedKeys: checkedKeys.checked, halfCheckedKeys: checkedKeys.halfChecked };\n    }\n\n    if (!props.checkStrictly) {\n      var checked = checkedKeys.checkedKeys || [];\n      var treeNodesStates = this.generateTreeNodesStates(props.children, checked);\n      return (0, _util.getCheck)(treeNodesStates);\n    }\n\n    return checkedKeys;\n  };\n\n  Tree.prototype.calcSelectedKeys = function calcSelectedKeys(props, isNotInit) {\n    var selectedKeys = props.selectedKeys || (isNotInit ? undefined : props.defaultSelectedKeys);\n    if (!selectedKeys) {\n      return undefined;\n    }\n    if (props.multiple) {\n      return [].concat(selectedKeys);\n    }\n    if (selectedKeys.length) {\n      return [selectedKeys[0]];\n    }\n    return selectedKeys;\n  };\n\n  Tree.prototype.calcDropPosition = function calcDropPosition(e, treeNode) {\n    var offsetTop = (0, _util.getOffset)(treeNode.selectHandle).top;\n    var offsetHeight = treeNode.selectHandle.offsetHeight;\n    var pageY = e.pageY;\n    var gapHeight = 2; // TODO: remove hard code\n    if (pageY > offsetTop + offsetHeight - gapHeight) {\n      return 1;\n    }\n    if (pageY < offsetTop + gapHeight) {\n      return -1;\n    }\n    return 0;\n  };\n\n  Tree.prototype.renderTreeNode = function renderTreeNode(child, index) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var state = this.state,\n        props = this.props;\n\n    var pos = level + '-' + index;\n    var key = child.key || pos;\n\n    var childProps = {\n      root: this,\n      eventKey: key,\n      pos: pos,\n      loadData: props.loadData,\n      prefixCls: props.prefixCls,\n      showIcon: props.showIcon,\n      draggable: props.draggable,\n      dragOver: state.dragOverNodeKey === key && state.dropPosition === 0,\n      dragOverGapTop: state.dragOverNodeKey === key && state.dropPosition === -1,\n      dragOverGapBottom: state.dragOverNodeKey === key && state.dropPosition === 1,\n      expanded: state.expandedKeys.indexOf(key) !== -1,\n      selected: state.selectedKeys.indexOf(key) !== -1,\n      openTransitionName: this.getOpenTransitionName(),\n      openAnimation: props.openAnimation,\n      filterTreeNode: this.filterTreeNode\n    };\n    if (props.checkable) {\n      childProps.checkable = props.checkable;\n      childProps.checked = state.checkedKeys.indexOf(key) !== -1;\n      childProps.halfChecked = state.halfCheckedKeys.indexOf(key) !== -1;\n    }\n    return _react2.default.cloneElement(child, childProps);\n  };\n\n  Tree.prototype.render = function render() {\n    var _classNames;\n\n    var props = this.props;\n    var className = (0, _classnames2.default)(props.prefixCls, props.className, (_classNames = {}, _classNames[props.prefixCls + '-show-line'] = props.showLine, _classNames));\n    var domProps = {};\n    if (props.focusable) {\n      domProps.tabIndex = '0';\n      domProps.onKeyDown = this.onKeyDown;\n    }\n\n    return _react2.default.createElement('ul', (0, _extends3.default)({}, domProps, {\n      className: className,\n      role: 'tree-node',\n      unselectable: 'on'\n    }), _react2.default.Children.map(props.children, this.renderTreeNode, this));\n  };\n\n  return Tree;\n}(_react2.default.Component);\n\nTree.propTypes = {\n  prefixCls: _propTypes2.default.string,\n  children: _propTypes2.default.any,\n  showLine: _propTypes2.default.bool,\n  showIcon: _propTypes2.default.bool,\n  selectable: _propTypes2.default.bool,\n  multiple: _propTypes2.default.bool,\n  checkable: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.node]),\n  checkStrictly: _propTypes2.default.bool,\n  draggable: _propTypes2.default.bool,\n  autoExpandParent: _propTypes2.default.bool,\n  defaultExpandAll: _propTypes2.default.bool,\n  defaultExpandedKeys: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  expandedKeys: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  defaultCheckedKeys: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  checkedKeys: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.string), _propTypes2.default.object]),\n  defaultSelectedKeys: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  selectedKeys: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  onExpand: _propTypes2.default.func,\n  onCheck: _propTypes2.default.func,\n  onSelect: _propTypes2.default.func,\n  loadData: _propTypes2.default.func,\n  onMouseEnter: _propTypes2.default.func,\n  onMouseLeave: _propTypes2.default.func,\n  onRightClick: _propTypes2.default.func,\n  onDragStart: _propTypes2.default.func,\n  onDragEnter: _propTypes2.default.func,\n  onDragOver: _propTypes2.default.func,\n  onDragLeave: _propTypes2.default.func,\n  onDrop: _propTypes2.default.func,\n  onDragEnd: _propTypes2.default.func,\n  filterTreeNode: _propTypes2.default.func,\n  openTransitionName: _propTypes2.default.string,\n  openAnimation: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])\n};\nTree.childContextTypes = contextTypes;\nTree.defaultProps = {\n  prefixCls: 'rc-tree',\n  showLine: false,\n  showIcon: true,\n  selectable: true,\n  multiple: false,\n  checkable: false,\n  checkStrictly: false,\n  draggable: false,\n  autoExpandParent: true,\n  defaultExpandAll: false,\n  defaultExpandedKeys: [],\n  defaultCheckedKeys: [],\n  defaultSelectedKeys: [],\n  onExpand: noop,\n  onCheck: noop,\n  onSelect: noop,\n  onDragStart: noop,\n  onDragEnter: noop,\n  onDragOver: noop,\n  onDragLeave: noop,\n  onDrop: noop,\n  onDragEnd: noop,\n  onMouseEnter: noop,\n  onMouseLeave: noop\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this.onCheck = function (treeNode) {\n    var props = _this4.props,\n        state = _this4.state;\n\n    var checked = !treeNode.props.checked || treeNode.props.halfChecked;\n    var eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked: checked\n    };\n\n    if (props.checkStrictly) {\n      var eventKey = treeNode.props.eventKey;\n      var checkedKeys = [].concat(state.checkedKeys);\n      var index = checkedKeys.indexOf(eventKey);\n      if (checked && index === -1) {\n        checkedKeys.push(eventKey);\n      }\n      if (!checked && index > -1) {\n        checkedKeys.splice(index, 1);\n      }\n\n      eventObj.checkedNodes = [];\n      (0, _util.traverseTreeNodes)(props.children, function (item) {\n        if (checkedKeys.indexOf(item.key) !== -1) {\n          eventObj.checkedNodes.push(item);\n        }\n      });\n\n      if (!('checkedKeys' in props)) {\n        _this4.setState({\n          checkedKeys: checkedKeys\n        });\n      }\n      props.onCheck((0, _util.getStrictlyValue)(checkedKeys, state.halfCheckedKeys), eventObj);\n    } else {\n      var treeNodesStates = _this4.generateTreeNodesStates(props.children, state.checkedKeys);\n      treeNodesStates[treeNode.props.pos].checked = checked;\n      treeNodesStates[treeNode.props.pos].halfChecked = false;\n      (0, _util.updateCheckState)(treeNodesStates, treeNode.props.pos, checked);\n\n      var checkKeys = (0, _util.getCheck)(treeNodesStates);\n      eventObj.checkedNodes = checkKeys.checkedNodes;\n      eventObj.checkedNodesPositions = checkKeys.checkedNodesPositions; // TODO: not in API\n      eventObj.halfCheckedKeys = checkKeys.halfCheckedKeys; // TODO: not in API\n\n      if (!('checkedKeys' in props)) {\n        _this4.setState({\n          checkedKeys: checkKeys.checkedKeys,\n          halfCheckedKeys: checkKeys.halfCheckedKeys\n        });\n      }\n      props.onCheck(checkKeys.checkedKeys, eventObj);\n    }\n  };\n\n  this.onKeyDown = function (e) {\n    e.preventDefault();\n  };\n\n  this.filterTreeNode = function (treeNode) {\n    var filterTreeNode = _this4.props.filterTreeNode;\n    if (typeof filterTreeNode !== 'function' || treeNode.props.disabled) {\n      return false;\n    }\n    return filterTreeNode.call(_this4, treeNode);\n  };\n};\n\nexports.default = Tree;"},"hash":"01b97b0453b0db0518138cc1cdf123ce"}